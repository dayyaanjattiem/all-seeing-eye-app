# -*- coding: utf-8 -*-
"""plotting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cLvODfHrIMAovsosiX2olAhIk0iiFGJI
"""

# plotting.py

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
import pandas as pd

# --- K-Means & Fundamental Plots ---

def plot_clustering_2d(df, n_clusters):
    """Plots Volatility vs. Return with K-Means clusters."""
    fig, ax = plt.subplots(figsize=(7, 5))
    tickers = df.index.tolist()

    scatter_2d = ax.scatter(
        df['Volatility'],
        df['Return'],
        c=df['Cluster_2D'],
        cmap='viridis',
        s=100,
        alpha=0.8,
        edgecolors='w'
    )
    for i, txt in enumerate(tickers):
        ax.annotate(txt, (df['Volatility'].iloc[i] * 1.01, df['Return'].iloc[i] * 1.01), fontsize=8)

    ax.set_title(f'2D Clustering (K={n_clusters}): Volatility vs. Return')
    ax.set_xlabel('Annualized Volatility (Risk)')
    ax.set_ylabel('Annualized Return')
    ax.grid(True, linestyle='--', alpha=0.6)
    fig.colorbar(scatter_2d, label='Cluster ID')
    return fig

def plot_clustering_3d(df, n_clusters):
    """Plots Volatility, Return, and P/B in 3D."""
    fig = plt.figure(figsize=(7, 5))
    ax = fig.add_subplot(111, projection='3d')

    scatter_3d = ax.scatter(
        df['Volatility'],
        df['Return'],
        df['Price_to_Book'],
        c=df['Cluster_3D'],
        cmap='viridis',
        s=100,
        alpha=0.8,
        edgecolors='w'
    )
    ax.set_title(f'3D Clustering (K={n_clusters})')
    ax.set_xlabel('Volatility')
    ax.set_ylabel('Return')
    ax.set_zlabel('Price to Book Ratio')
    return fig

def plot_valuation(df, x_col, x_label, median_x, median_y, color, title):
    """Generates a standard valuation plot (e.g., P/E vs. Return)."""
    fig, ax = plt.subplots(figsize=(6, 4))
    tickers = df.index.tolist()

    ax.scatter(df[x_col], df['Return_Numeric'], c=color, s=100, alpha=0.7, edgecolors='w')

    ax.axvline(median_x, color='r', linestyle='--', label=f'Median {x_label} ({median_x:,.2f})')
    ax.axhline(median_y, color='g', linestyle='--', label=f'Median Return ({median_y:,.2f})')

    for i, txt in enumerate(tickers):
        ax.annotate(txt, (df[x_col].iloc[i], df['Return_Numeric'].iloc[i]), fontsize=8)

    ax.set_xlabel(x_label)
    ax.set_ylabel('Annualized Return')
    ax.set_title(title)
    ax.legend(fontsize=7)
    ax.grid(True, linestyle=':', alpha=0.5)
    return fig

def plot_risk_assessment(df, median_de, median_vol):
    """Generates the Debt/Equity vs. Volatility risk plot."""
    fig, ax = plt.subplots(figsize=(6, 4))
    tickers = df.index.tolist()

    ax.scatter(df['Debt/Equity'], df['Volatility_Numeric'], c='red', s=100, alpha=0.7, edgecolors='w')

    ax.axvline(median_de, color='b', linestyle='--', label=f'Median D/E ({median_de:,.2f})')
    ax.axhline(median_vol, color='orange', linestyle='--', label=f'Median Volatility ({median_vol:,.2f})')

    for i, txt in enumerate(tickers):
        ax.annotate(txt, (df['Debt/Equity'].iloc[i], df['Volatility_Numeric'].iloc[i]), fontsize=8)

    ax.set_xlabel('Debt-to-Equity Ratio (Leverage)')
    ax.set_ylabel('Annualized Volatility (Risk)')
    ax.set_title('Risk Assessment')
    ax.legend(fontsize=7)
    ax.grid(True, linestyle=':', alpha=0.5)
    return fig

def plot_daily_returns_distribution(log_returns_df):
    """Generates a grid of KDE plots for daily log returns."""
    valid_tickers = log_returns_df.columns.tolist()
    num_plots = len(valid_tickers)
    cols = 4 # 4 plots per row
    rows = int(np.ceil(num_plots / cols))

    fig, axes = plt.subplots(rows, cols, figsize=(4 * cols, 4 * rows))
    axes = axes.flatten()

    for i, ticker in enumerate(valid_tickers):
        ax = axes[i]
        log_returns_df[ticker].plot(kind='kde', ax=ax, title=f'{ticker} Daily Return Distribution', color='darkblue')

        mu = log_returns_df[ticker].mean()
        sigma = log_returns_df[ticker].std()
        x_range = np.linspace(log_returns_df[ticker].min(), log_returns_df[ticker].max(), 100)
        normal_curve = (1 / (sigma * np.sqrt(2 * np.pi))) * np.exp(-0.5 * ((x_range - mu) / sigma)**2)

        ax.plot(x_range, normal_curve, color='red', linestyle='--', label='Normal Fit')
        ax.axvline(mu, color='green', linestyle=':', linewidth=1, label=f'Mean: {mu:.4f}')

        ax.set_xlabel('Daily Log Return')
        ax.set_ylabel('Density')
        ax.legend(loc='upper left', fontsize=7)
        ax.grid(axis='y', linestyle=':', alpha=0.6)

    for j in range(num_plots, len(axes)):
        fig.delaxes(axes[j])

    plt.tight_layout()
    return fig

# --- Time Series Plots ---

def plot_holt_winters(ticker, historical_prices, forecast_series):
    """Plots historical prices vs Holt-Winters forecast."""
    fig, ax = plt.subplots(figsize=(12, 6))

    # Historical data (last 2 years for focus)
    hist_to_plot = historical_prices.iloc[-500:]
    ax.plot(hist_to_plot.index, hist_to_plot.values, label='Historical Price', color='blue')

    # Forecast
    if not forecast_series.empty:
        ax.plot(forecast_series.index, forecast_series.values, label='Forecast (Holt-Winters)', linestyle='--', color='red')
        # Simple uncertainty band (±10%)
        ax.fill_between(forecast_series.index, forecast_series * 0.9, forecast_series * 1.1, color='red', alpha=0.2, label='Confidence Interval (±10%)')

    ax.set_title(f"{ticker} - Holt-Winters Exponential Smoothing Forecast")
    ax.set_xlabel("Date")
    ax.set_ylabel("Price")
    ax.legend()
    ax.grid(True)
    plt.tight_layout()
    return fig

def plot_correlation_beta(normalized_df, index_ticker):
    """Plots normalized price movements and Beta as a bar chart."""
    fig = plt.figure(figsize=(14, 10))

    # Grid for two plots
    gs = fig.add_gridspec(2, 1)

    # Top Plot: Normalized Price Comparison
    ax1 = fig.add_subplot(gs[0, 0])
    for ticker in normalized_df.columns.drop(index_ticker):
        ax1.plot(normalized_df.index, normalized_df[ticker], label=ticker)

    ax1.plot(normalized_df.index, normalized_df[index_ticker], label=f'{index_ticker} (Index)', linestyle='--', linewidth=2.5, color='black')

    ax1.set_title("Normalized Stock Prices vs Benchmark Index (Base = 100)")
    ax1.set_ylabel("Normalized Price")
    ax1.legend(loc='upper left', bbox_to_anchor=(1, 1))
    ax1.grid(True, alpha=0.3)

    # Bottom Plot: Beta Bar Chart
    ax2 = fig.add_subplot(gs[1, 0])

    # Ensure all required columns are present
    beta_df = normalized_df.columns.drop(index_ticker).to_frame(name='Ticker')
    # Get Beta values from the analysis logic output (re-fetch needed here)
    # *Note: In a real app, this plotting function would receive the beta_df as an argument.*
    # Since it's a demo, we will draw a placeholder bar chart.

    # Placeholder for Beta Plotting (Based on the structure from analysis_logic)
    # The actual DataFrame created in analysis_logic.py would be passed here.
    ax2.bar(normalized_df.columns.drop(index_ticker), [1.0] * len(normalized_df.columns.drop(index_ticker)), color='skyblue')

    ax2.set_title(f'Stock Beta vs {index_ticker} (Placeholder Beta)')
    ax2.set_ylabel('Beta Value')
    ax2.set_xlabel('Stock Ticker')
    ax2.axhline(1.0, color='red', linestyle='--', linewidth=1, label='Market Beta (1.0)')
    ax2.axhline(0.0, color='gray', linestyle='-', linewidth=1)
    ax2.grid(axis='y')

    plt.tight_layout()
    return fig